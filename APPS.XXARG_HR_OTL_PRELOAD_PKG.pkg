CREATE OR REPLACE PACKAGE XXARG_HR_OTL_PRELOAD_PKG AUTHID CURRENT_USER as

/*******************************************************************************
*         $Header: xxhrotlpreload.sql 115.0 23-JUN-2009 kvsankar $             *
*             Copyright (c) 2009, by Wendy's Arby's Group                      *
*                                                                              *
*   Package Name     :  XXHR_OTL_PRELOAD_PKG                                   *
*   Author           :  Kumaresan Sankaranarayanan, Polaris                    *
*   Description      :  This package is used to preload data for all eligible  *
*                       employees based on payroll                             *
*                                                                              *
* HISTORY                                                                      *
* Changed BY     Change Date   Version  Comments                               *
* -------------  ------------  -------  ---------------------------------------*
*  Kumaresan      23-JUN-2009    115.0  Initial Version                        *
*                                                                              *
*******************************************************************************/

procedure preload(errbuf    OUT VARCHAR2
                 ,retcode   OUT VARCHAR2
                 ,p_payroll  IN NUMBER);


procedure upd_ctrl_tbl(errbuf        OUT VARCHAR2
                      ,retcode       OUT VARCHAR2
                      ,p_payroll     IN VARCHAR2
                      ,p_pd_end_date IN VARCHAR2
                      ,p_status      IN VARCHAR2);

procedure del_ctrl_tbl(errbuf        OUT VARCHAR2
                      ,retcode       OUT VARCHAR2
                      ,p_payroll     IN VARCHAR2
                      ,p_pd_end_date IN VARCHAR2);

procedure ins_ctrl_tbl(errbuf        OUT VARCHAR2
                      ,retcode       OUT VARCHAR2
                      ,p_payroll     IN  VARCHAR2
                      ,p_pd_end_date IN  VARCHAR2);

-- Global Variables
gd_w1_start     date;
gd_w1_end       date;
gd_w2_start     date;
gd_w2_end       date;
gd_pd_start     date;
gd_pd_end       date;

gv_debug_mode   varchar2(10) := 'N';
g_error_msg     VARCHAR2(2000);
g_retcode       NUMBER;

gv_pkg_name     constant varchar2(100) := 'XXARG_HR_OTL_PRELOAD_PKG';

g_tbl_timecard_info   hxc_self_service_time_deposit.timecard_info;
g_tbl_attributes_info hxc_self_service_time_deposit.app_attributes_info;

end xxarg_hr_otl_preload_pkg;

/
CREATE OR REPLACE PACKAGE BODY XXARG_HR_OTL_PRELOAD_PKG as

/*******************************************************************************
*         $Header: XXARG_HR_OTL_PRELOAD_PKG.pkb 115.0 23-JUN-2009 kvsankar $   *
*             Copyright (c) 2009, by Wendy's Arby's Group                      *
*                                                                              *
*   Package Name     :  XXARG_HR_OTL_PRELOAD_PKG                               *
*   Author           :  Kumaresan Sankaranarayanan, Polaris                    *
*   Description      :  This package is used to preload data for all eligible  *
*                       employees based on payroll                             *
*                                                                              *
* HISTORY                                                                      *
* Changed BY     Change Date   Version  Comments                               *
* -------------  ------------  -------  ---------------------------------------*
*  Kumaresan      23-JUN-2009    115.0  Initial Version                        *
*                                                                              *
*******************************************************************************/

/*******************************************************************************
    Name         :   PRINT_MESSAGES
    Scope        :   LOCAL
    Descirption  :   This function is used to write the error messages that are
                     stored in the MESSAGE TABLE returned by EXECUTE_DEPOSIT
                     process
*******************************************************************************/
PROCEDURE PRINT_MESSAGES(p_emp_num varchar2
                        ,p_date    date
                        ,p_msg_tbl hxc_self_service_time_deposit.message_table)
IS
   lv_message     varchar2(32767);
   i          number; -- Counter
BEGIN


   -- Print messages only if the message count > 0
   if (p_msg_tbl.COUNT <> 0) then -- messages have been returned
      xxarg_hr_util_pkg.debug(gv_debug_mode
                         ,gv_pkg_name || '.print_messages', 10);
      xxarg_hr_util_pkg.debug_message(gv_debug_mode
                                 ,'Error Count for ' || p_emp_num || ' = ' ||
                                   p_msg_tbl.COUNT);

      i := p_msg_tbl.FIRST;
      loop
         exit when (not p_msg_tbl.exists (i));
         -- First translate the message as the messagetable returned does not
         -- give the actual message, only the message_name which doesn't
         -- mean anything to the user.
         lv_message := fnd_message.get_string(
                         appin => p_msg_tbl(i).application_short_name
                        ,namein=> p_msg_tbl(i).message_name);
                        
         lv_message := substr(lv_message,0,instr(lv_message
                                                , chr(10)) - 1);
         fnd_file.put_line (fnd_file.output
                           ,lpad(p_emp_num,15,' ') || '    ' ||
                            to_char(p_date,'DD-MON-YYYY') || '     ' ||
                            rpad(p_msg_tbl(i).message_name,35) ||
                            lv_message);
         i := p_msg_tbl.NEXT (i);
      end loop;
      xxarg_hr_util_pkg.debug(gv_debug_mode
                         ,gv_pkg_name || '.print_messages', 30);
   end if; -- if (p_msg_tbl.COUNT <> 0)

END PRINT_MESSAGES;

/*******************************************************************************
    Name         :   INS_INTO_TC_SOURCE
    Scope        :   LOCAL
    Descirption  :   This procedure is to insert into TC Source table
*******************************************************************************/
PROCEDURE INS_INTO_TC_SOURCE(pi_sys_source  varchar2
                            ,pi_pers_id     number
                            ,pi_wk_end_date date) is

cursor c_chk_exists is
select 'Exists'
  from XXARG.XXARG_HR_TC_SOURCE
 where system_source = pi_sys_source
   and person_id = pi_pers_id
   and week_end_date = pi_wk_end_date;
   
   lv_exists varchar2(30);
   
BEGIN

   open c_chk_exists;
   fetch c_chk_exists into lv_exists;
   if c_chk_exists%notfound then
      insert into XXARG.XXARG_HR_TC_SOURCE
              (system_source
              ,person_id
              ,week_end_date
              ,last_update_date
              ,last_updated_by
              ,creation_date
              ,created_by
              )
        values(pi_sys_source
              ,pi_pers_id
              ,pi_wk_end_date
              ,sysdate
              ,fnd_global.user_id
              ,sysdate
              ,fnd_global.user_id);
   end if;
   close c_chk_exists;

END INS_INTO_TC_SOURCE;

/*******************************************************************************
    Name         :   CREATE_TIMECARD
    Scope        :   LOCAL
    Descirption  :   This procedure is used to create timecards for the PERSON
                     and Element passed in. The timecard are
                     created as of the DATE passed in as parameter.
*******************************************************************************/
PROCEDURE CREATE_TIMECARD(p_person_id       in number
                         ,p_empl_nbr        in varchar2
                         ,p_hours           in number
                         ,p_ele_type_id     in number
                         ,p_te_date         in date
                         ,p_pay_basis_id    in number) IS


   ln_tc_id          number;
   ln_obj_ver        number;

   l_tb_block_id         hxc_time_building_blocks.time_building_block_id%TYPE;

BEGIN

   xxarg_hr_util_pkg.debug(gv_debug_mode
                      ,'Entering ' || gv_pkg_name || '.create_timecard', 10);

   begin
      -- Create Time Entry for Time Entry Wages
      -- This process stores the time entry details in PL/SQL tables and not in
      -- database
      hxc_timestore_deposit.create_time_entry(
                       p_measure                => p_hours
                      ,p_day                    => p_te_date
                      ,p_resource_id            => p_person_id
                      ,p_comment_text           => NULL
                      ,p_app_blocks             => g_tbl_timecard_info
                      ,p_app_attributes         => g_tbl_attributes_info
                      ,p_time_building_block_id => l_tb_block_id);

      -- Create Hours Attribute to associate the Time Entry Wages Element
      hxc_timestore_deposit.create_attribute(
                       p_building_block_id  => l_tb_block_id
                      ,p_attribute_name     => 'Dummy Element Context'
                      ,p_attribute_value    => 'ELEMENT - ' || p_ele_type_id
                      ,p_app_attributes     => g_tbl_attributes_info);

       -- Create Salary Basis Attribute
       hxc_timestore_deposit.create_attribute(
                       p_building_block_id   => l_tb_block_id
                      ,p_attribute_name      => 'WAG PayBasisId'
                      ,p_attribute_value     => p_pay_basis_id
                      ,p_app_attributes      => g_tbl_attributes_info);


   xxarg_hr_util_pkg.debug(gv_debug_mode
                      ,'Leaving ' || gv_pkg_name || '.create_timecard', 10);

   exception
      when others then
         -- Should not come over here
         null;
   end;

   xxarg_hr_util_pkg.debug(gv_debug_mode
                      ,'Leaving ' || gv_pkg_name || '.create_timecard', 10);

END CREATE_TIMECARD;

/*******************************************************************************
    Name         :   CREATE_TIMECARD
    Scope        :   LOCAL
    Descirption  :   This procedure is used to create timecards for the PERSON
                     and Element passed in. The timecard are
                     created as of the DATE passed in as parameter.
*******************************************************************************/
PROCEDURE EXECUTE_DEPOSIT(p_empl_nbr    varchar2
                         ,p_wk_end_date date) IS

   ln_tc_id          number;
   ln_obj_ver        number;

   l_tbl_messages        hxc_self_service_time_deposit.message_table;


BEGIN

   xxarg_hr_util_pkg.debug(gv_debug_mode
                      ,'Entering ' || gv_pkg_name || '.execute_deposit', 10);

   begin
      -- Execute Deposit Process for all employees for the Time Entry to be
      -- created in database
      hxc_timestore_deposit.execute_deposit_process(
                          p_validate             => FALSE
                         ,p_app_blocks           => g_tbl_timecard_info
                         ,p_app_attributes       => g_tbl_attributes_info
                         ,p_messages             => l_tbl_messages
                         ,p_mode                 => 'SUBMIT'
                         ,p_deposit_process      => 'OTL Deposit Process'
                         ,p_timecard_id          => ln_tc_id
                         ,p_timecard_ovn         => ln_obj_ver);

      -- Print any error messages returned by the EXECUTE process above
      if ln_tc_id is null then
         g_retcode := 1;
         g_error_msg := 'Error preloading timecard for a few employees. Please check output file for details';
         print_messages(p_empl_nbr
                       ,p_wk_end_date
                       ,l_tbl_messages);
      end if;

   xxarg_hr_util_pkg.debug(gv_debug_mode
                      ,'Leaving ' || gv_pkg_name || '.execute_deposit', 20);


   exception
      when others then
         -- Print any error messages returned by the EXECUTE process above
         print_messages(p_empl_nbr
                       ,nvl(gd_w2_end,gd_w1_end)
                       ,l_tbl_messages);
   end;

END EXECUTE_DEPOSIT;

/*******************************************************************************
    Name         :   POP_EMPL_TIMECARD
    Scope        :   LOCAL
    Descirption  :   This procedure is used to identify all employees whose
                     TIMECARD has to be loaded. The procedure in turn calls
                     CREATE_TIMECARD to create timecard for identified
                     employees
*******************************************************************************/
PROCEDURE POP_EMPL_TIMECARD(p_pay_id      number
                           ,p_pay_name    varchar2
                           ,p_bus_grp_id  number) is

-- Cursor to get all employees belonging to WAGARG payroll
cursor c_get_emp_wagarg(cp_payroll_id  number
                       ,cp_p1_end_date date
                       ,cp_p2_end_date date) is
select distinct
       papf.person_id
      ,papf.employee_number
      ,ppos.date_start
      ,ppos.actual_termination_date
      ,paf.assignment_id
      ,paf.pay_basis_id
  from per_all_people_f papf
      ,per_periods_of_service ppos
      ,per_all_assignments_f paf
 where paf.payroll_id = cp_payroll_id
   and papf.person_id = paf.person_id
   and paf.primary_flag = 'Y'
   and ppos.period_of_service_id = paf.period_of_service_id
   and ppos.person_id = papf.person_id
   and (ppos.actual_termination_date is null or ppos.actual_termination_date >= cp_p1_end_date)
   and cp_p2_end_date between papf.effective_start_date
                          and papf.effective_end_date
   and ((cp_p1_end_date between paf.effective_start_date
                            and paf.effective_end_date)
         or
        (cp_p2_end_date between paf.effective_start_date
                            and paf.effective_end_date))
   -- Using Process Control to get the list of Assignment Status Type IDs
   -- For performance reasons, no dynamic query is used here
   and paf.assignment_status_type_id not in(
                        select assignment_status_type_id
                          from per_assignment_status_types
                         where user_status in ('FMLA - Non Medical'
                                              ,'FMLA Medical'
                                              ,'Non FMLA - Medical'
                                              ,'Involuntary Suspension'
                                              ,'WCB Ohio'
                                              ,'WCB Flux'
                                              ,'Student LOA'
                                              ,'Personal Leave'
                                              ,'California Pregnancy Disability Leave'
                                              ,'California Family Rights Act Leave'
                                              ,'Extended Military LOA'
                                              ,'Military LOA'
                                              ,'Adoption Leave'
                                              ,'STD - Pending'
                                              ,'LTD - Pending'
                                              ,'LTD - Paid'
                                              ,'STD - Paid'
                                              ,'FMLA/Medical Leave Pending'
                                              ,'Severance (LOA)'
                                              ,'WCB Unpaid'
                                               )
                                            );
/*   and paf.assignment_status_type_id not in (
                         select dtls.criteria_value
                           from xxarg_hr_pcs pcs
                               ,xxarg_hr_pc_dtls dtls
                          where pcs.process_id = dtls.process_id
                            and trunc(sysdate) between pcs.effective_start_date
                                                   and pcs.effective_end_date
                            and trunc(sysdate) between dtls.effective_start_date
                                                   and dtls.effective_end_date
                            and dtls.criteria_code = 'ASSIGNMENT_STATUS_TYPE'
                            and pcs.process_name ='OTL_PRELOAD(US)');*/

-- Cursor to get all eligible employees belonging to US
-- in the payroll passed in
cursor c_get_emp_us_oth(cp_payroll_id  number
                       ,cp_p1_end_date date
                       ,cp_p2_end_date date) is
select distinct
       papf.person_id
      ,papf.employee_number
      ,ppos.date_start
      ,ppos.actual_termination_date
      ,paf.assignment_id
      ,hl.attribute1
      ,paf.payroll_id
      ,paf.pay_basis_id
  from per_all_people_f papf
      ,per_periods_of_service ppos
      ,per_all_assignments_f paf
      ,hr_locations_all hl
      ,hr_organization_units hou
      ,pay_payrolls_f ppf
 where paf.payroll_id = cp_payroll_id
   and papf.person_id = paf.person_id
   and paf.primary_flag = 'Y'
   and ppos.period_of_service_id = paf.period_of_service_id
   and ppos.person_id = papf.person_id
   and hl.location_id = paf.location_id
   and paf.payroll_id = ppf.payroll_id
   and ppf.payroll_name != 'WENBAK'
   and (ppos.actual_termination_date is null or ppos.actual_termination_date >= cp_p1_end_date)
   and paf.organization_id = hou.organization_id
   and (hou.name not like 'Wendys%' and ppf.payroll_name in ('WENBW1','WENBW2','WENWKLY'))
   -- Using Process Control to get the list of Location IDs
   -- For performance reasons, no dynamic query is used here
   -- Logacy Location Codes added
   -- '0001','0008','0010','0206','0215','0279','0284','0388','0451','0517',
   -- '0522','0565','0642','0810','0925','0986','1109','1129','1226','1229',
   -- '1317','1398','1513','1746','1748','1749','2045','2302','2611','2694'
/*   and hl.attribute1 in ('0001','0008','0010','0206','0215','0279','0284'
                        ,'0388','0451','0517','0522','0565','0642','0810'
                        ,'0925','0986','1109','1129','1226','1229','1317'
                        ,'1398','1513','1746','1748','1749','2045','2302'
                        ,'2611','2694','2737') */
/*   and hl.location_id in (
                         select dtls.criteria_value
                           from xxarg_hr_pcs pcs
                               ,xxarg_hr_pc_dtls dtls
                          where pcs.process_id = dtls.process_id
                            and trunc(sysdate) between pcs.effective_start_date
                                                   and pcs.effective_end_date
                            and trunc(sysdate) between dtls.effective_start_date
                                                   and dtls.effective_end_date
                            and dtls.criteria_code = 'LEGACY_LOCATION'
                            and pcs.process_name = 'OTL_PRELOAD(US)')*/
   -- Using Process Control to get the list of Assignment Status Type IDs
   -- For performance reasons, no dynamic query is used here
   and paf.assignment_status_type_id not in(
                        select assignment_status_type_id
                          from per_assignment_status_types
                         where user_status in ('FMLA - Non Medical'
                                              ,'FMLA Medical'
                                              ,'Non FMLA - Medical'
                                              ,'Involuntary Suspension'
                                              ,'WCB Ohio'
                                              ,'WCB Flux'
                                              ,'Student LOA'
                                              ,'Personal Leave'
                                              ,'California Pregnancy Disability Leave'
                                              ,'California Family Rights Act Leave'
                                              ,'Extended Military LOA'
                                              ,'Military LOA'
                                              ,'Adoption Leave'
                                              ,'STD - Pending'
                                              ,'LTD - Pending'
                                              ,'LTD - Paid'
                                              ,'STD - Paid'
                                              ,'FMLA/Medical Leave Pending'
                                              ,'Severance (LOA)'
                                              ,'WCB Unpaid'
                                               )
                                            )
/*   and paf.assignment_status_type_id not in (
                         select dtls.criteria_value
                           from xxarg_hr_pcs pcs
                               ,xxarg_hr_pc_dtls dtls
                          where pcs.process_id = dtls.process_id
                            and trunc(sysdate) between pcs.effective_start_date
                                                   and pcs.effective_end_date
                            and trunc(sysdate) between dtls.effective_start_date
                                                   and dtls.effective_end_date
                            and dtls.criteria_code = 'ASSIGNMENT_STATUS_TYPE'
                            and pcs.process_name = 'OTL_PRELOAD(US)') */
   and cp_p2_end_date between papf.effective_start_date
                          and papf.effective_end_date
   and ((cp_p1_end_date between paf.effective_start_date
                            and paf.effective_end_date)
         or
        (cp_p2_end_date between paf.effective_start_date
                            and paf.effective_end_date));

-- Cursor to get all eligible employees belonging to CAN
-- in the payroll passed in
cursor c_get_emp_ca(cp_payroll_id  number
                   ,cp_p1_end_date date
                   ,cp_p2_end_date date) is
select distinct
       papf.person_id
      ,papf.employee_number
      ,ppos.date_start
      ,ppos.actual_termination_date
      ,paf.assignment_id
      ,paf.payroll_id
      ,paf.pay_basis_id
  from per_all_people_f papf
      ,per_periods_of_service ppos
      ,per_all_assignments_f paf
      ,hr_locations_all hl
      ,per_pay_bases ppb
      ,pay_payrolls_f ppf
      , hr_organization_units hou
 where paf.payroll_id = cp_payroll_id
   and papf.person_id = paf.person_id
   and paf.primary_flag = 'Y'
   and ppos.period_of_service_id = paf.period_of_service_id
   and ppos.person_id = papf.person_id
   and hl.location_id = paf.location_id
   and paf.pay_basis_id = ppb.pay_basis_id
--   and ppb.name in ('Salaried')
   and ppf.payroll_id = paf.payroll_id
   and (ppos.actual_termination_date is null or ppos.actual_termination_date >= cp_p1_end_date)
   -- Using Process Control to get the list of Location IDs
   -- For performance reasons, no dynamic query is used here
   -- Logacy Location Codes added
   -- '0001','0011','0014','0021','0043','0050','0051','0057','0074','0155',
   -- '0066','0029','0088','0003','0030','0031','0033','0041','0045','0156',
   -- '0168','0034','0036','0038','0154','0132','0149','0137'
 /*  and (hl.attribute1 in ('0001','0011','0014','0021','0043','0050','0051','0057'
                        ,'0074','0155','0066','0029','0088','0003','0030','0031'
                        ,'0033','0041','0045','0156','0168','0034','0036','0038'
                        ,'0154','0132','0149','0137') */
      and paf.organization_id = hou.organization_id
      and (hou.name not like 'Wenca 0%' and hou.name not like 'Wenca 1%')
/*   and hl.location_id in (
                         select dtls.criteria_value
                           from xxarg_hr_pcs pcs
                               ,xxarg_hr_pc_dtls dtls
                          where pcs.process_id = dtls.process_id
                            and trunc(sysdate) between pcs.effective_start_date
                                                   and pcs.effective_end_date
                            and trunc(sysdate) between dtls.effective_start_date
                                                   and dtls.effective_end_date
                            and dtls.criteria_code = 'LEGACY_LOCATION'
                            and pcs.process_name = 'OTL_PRELOAD(CA)')
                            */
   -- Using Process Control to get the list of Assignment Status Type IDs
   -- For performance reasons, no dynamic query is used here
   and paf.assignment_status_type_id not in (
                         select assignment_status_type_id
                          from per_assignment_status_types
                         where user_status in ('LTD Modified'
                                              ,'Maternity - Extended Leave'
                                              ,'STD Modified'
                                              ,'STD with Pay'
                                              ,'Personal Leave of Absence'
                                              ,'Unpaid Disb (Mod-Not Wrk Rel)'
                                              ,'Parental LOA'
                                              ,'Compassionate Care Leave'
                                              ,'Temporary Store Closure'
                                               )
                                             )
/*   and paf.assignment_status_type_id not in (
                         select dtls.criteria_value
                           from xxarg_hr_pcs pcs
                               ,xxarg_hr_pc_dtls dtls
                          where pcs.process_id = dtls.process_id
                            and trunc(sysdate) between pcs.effective_start_date
                                                   and pcs.effective_end_date
                            and trunc(sysdate) between dtls.effective_start_date
                                                   and dtls.effective_end_date
                            and dtls.criteria_code = 'ASSIGNMENT_STATUS_TYPE'
                            and pcs.process_name = 'OTL_PRELOAD(CA)')
                            */
   and cp_p2_end_date between papf.effective_start_date
                          and papf.effective_end_date
   and cp_p2_end_date between ppf.effective_start_date
                          and ppf.effective_end_date
   and ((cp_p1_end_date between paf.effective_start_date
                            and paf.effective_end_date)
         or
        (cp_p2_end_date between paf.effective_start_date
                            and paf.effective_end_date));

-- Cursor to get normal hours as of Week End date
-- This cursor checks for the valid assignment type ids from the Process
-- control
cursor c_get_emp_nh(cp_asg_id        number
                   ,cp_date          date) is
select paf.normal_hours
      ,hl.region_2
  from per_all_assignments_f paf
      ,hr_locations_all hl
 where paf.assignment_id = cp_asg_id
   and paf.primary_flag = 'Y'
   and paf.location_id = hl.location_id
   -- Using Process Control to get the list of Assignment Status Type IDs
   -- For performance reasons, no dynamic query is used here
/*   and paf.assignment_status_type_id not in (
                         select dtls.criteria_value
                           from xxarg_hr_pcs pcs
                               ,xxarg_hr_pc_dtls dtls
                          where pcs.process_id = dtls.process_id
                            and trunc(sysdate) between pcs.effective_start_date
                                                   and pcs.effective_end_date
                            and trunc(sysdate) between dtls.effective_start_date
                                                   and dtls.effective_end_date
                            and dtls.criteria_code = 'ASSIGNMENT_STATUS_TYPE'
                            and pcs.process_name = 'OTL_PRELOAD(US)')
                            */
   and paf.assignment_status_type_id not in(
                        select assignment_status_type_id
                          from per_assignment_status_types
                         where user_status in ('FMLA - Non Medical'
                                              ,'FMLA Medical'
                                              ,'WCB Ohio'
                                              ,'WCB Flux'
                                              ,'Student LOA'
                                              ,'Personal Leave'
                                              ,'California Pregnancy Disability Leave'
                                              ,'California Family Rights Act Leave'
                                              ,'Extended Military LOA'
                                              ,'Military LOA'
                                              ,'Adoption Leave'
                                              ,'STD - Pending'
                                              ,'LTD - Pending'
                                              ,'LTD - Paid'
                                              ,'STD - Paid'
                                              ,'FMLA/Medical Leave Pending'
                                              ,'Severance (LOA)'
                                              ,'WCB Unpaid'
                                               )
                                            )
   and cp_date between paf.effective_start_date
                   and paf.effective_end_date;

-- Cursor to get normal hours as of Week End date
-- This cursor checks for the valid assignment type ids from the Process
-- control
cursor c_get_emp_nh_ca(cp_asg_id        number
                      ,cp_date          date) is
select paf.normal_hours
      ,hl.region_1
  from per_all_assignments_f paf
      ,hr_locations_all hl
 where paf.assignment_id = cp_asg_id
   and paf.primary_flag = 'Y'
   and paf.location_id = hl.location_id
   and paf.assignment_status_type_id not in (
                         select assignment_status_type_id
                          from per_assignment_status_types
                         where user_status in ('LTD with Pay'
                                              ,'Maternity - Extended Leave'
                                              ,'STD with Pay'
                                              ,'Personal Leave of Absence'
                                              ,'Unpaid Disb (Mod-Not Wrk Rel)'
                                              ,'Parental LOA'
                                              ,'Compassionate Care Leave'
                                              ,'Temporary Store Closure'
                                               )
                                             )
   and cp_date between paf.effective_start_date
                   and paf.effective_end_date;

-- Cursor to Get Holiday Count based on the Holiday calendar assigned in
-- Assignment Time Information
cursor c_get_hol_cldr(cp_asg_id     number
                     ,cp_end_date   date) is
select hhc.name
      ,hhc.id
 from hxt_add_assign_info_f haai
     ,hxt_earning_policies hep
     ,hxt_holiday_calendars hhc
where haai.assignment_id = cp_asg_id
  and hep.id = haai.earning_policy
  and hhc.id = hep.hcl_id
  and cp_end_date between hep.effective_start_date
                      and hep.effective_end_date
  and cp_end_date between haai.effective_start_date
                      and haai.effective_end_date;

-- Cursor to Get Holiday Count based on the Holiday calendar specified in
-- as parameter
cursor c_get_hol_cnt_cldr(cp_cal_id      number
                         ,cp_start_date  date
                         ,cp_end_date    date) is
select holiday_date
 from hxt_holiday_days hhd
where hhd.hcl_id = cp_cal_id
  and trim(to_char(holiday_date,'DAY')) not in ('SUNDAY','SATURDAY')
  and hhd.holiday_date between cp_start_date
                           and cp_end_date;

   ln_reg_ele_type_id    number;
   ln_hol_ele_type_id    number;
   ln_ldr_ele_type_id    number;
   ln_norm_hours         number;
   ln_hol_cnt            number;
   ln_hol_hours          number;
   ln_te_hours           number;
   ln_hol_cldr_id        number;

   ld_hol_date           date;
   ld_week_start         date;
   ld_cur_te_date        date;

   lv_state              varchar2(10);
   lv_hol_cldr           varchar2(100);
   lv_prov               varchar2(10);

   vc_get_emp_wagarg c_get_emp_wagarg%rowtype;
   vc_get_emp_us_oth c_get_emp_us_oth%rowtype;
   vc_get_emp_ca     c_get_emp_ca%rowtype;

BEGIN

   xxarg_hr_util_pkg.debug(gv_debug_mode
                      ,'Entering ' || gv_pkg_name || '.pop_empl_timecard', 10);

   -- Creating a report for all errored employees
   -- Below is the Header Section of the report
   fnd_file.put_line(fnd_file.output
                    ,'EMPLOYEE_NUMBER   TIMECARD DATE    MESSAGE_NAME                       MESSAGE_TEXT');
   fnd_file.put_line(fnd_file.output
                    ,'---------------   -------------    ------------                       ----------------------------');

   -- Check whether payroll is 'WAGARG'
   -- If Payroll = 'WAGARG' then
   --    Populate timecard for all employees
   -- If Payroll <> 'WAGARG' then
   --    Check if Business Group is 'US'
   --    If BG is 'US' then
   --       Use the location code specified in Process Control 1
   --       to identify employees who have to be processed
   --    If BG is 'CA' then
   --       Use the location code specified in Process Control 2
   --       to identify employees who have to be processed
   if p_pay_name = 'WAGARG' then

      -- Fetch Element Type ID for Time Entry Wages
      -- This element type id is further used in creating Timecards for Time
      -- Entry Wages
      begin
         select element_type_id
           into ln_reg_ele_type_id
           from pay_element_types_f
          where element_name = 'REG'
            and business_group_id = p_bus_grp_id
            and trunc(sysdate) between effective_start_date
                                   and effective_end_date;

         -- Fetch Element Type ID for Holiday(US)
         -- This element type id is further used in creating Timecards for Holiday
         select element_type_id
           into ln_hol_ele_type_id
           from pay_element_types_f
          where element_name = 'HOL'
            and business_group_id = p_bus_grp_id
            and trunc(sysdate) between effective_start_date
                                   and effective_end_date;
       exception
          when others then
             xxarg_hr_util_pkg.debug(gv_debug_mode
                                    ,gv_pkg_name || '.pop_empl_timecard', 15);
             xxarg_hr_util_pkg.debug_message(
                                     gv_debug_mode
                                    ,'Element Not Found');
             raise;
       end;

      xxarg_hr_util_pkg.debug(gv_debug_mode
                             ,gv_pkg_name || '.pop_empl_timecard', 20);

      -- Fetch all employees for whome Timecard has to be loaded
      open c_get_emp_wagarg(p_pay_id
                           ,gd_pd_start + 6
                           ,gd_pd_end);
      <<WAGARG_EMP_LOOP>>
      loop

         g_tbl_timecard_info.delete();
         g_tbl_attributes_info.delete();

         fetch c_get_emp_wagarg into vc_get_emp_wagarg;
         exit when c_get_emp_wagarg%notfound;

         -- Week1 Timecard starts here
         -- Fetch Normal hours for Week1 and check whether Assignment is
         -- eligible for Time Entry for Week1
         -- The check is done in the cursor c_get_emp_nh
         open c_get_emp_nh(vc_get_emp_wagarg.assignment_id
                          ,gd_w1_end);
         fetch c_get_emp_nh into ln_norm_hours
                                ,lv_state;
         if c_get_emp_nh%FOUND then

             xxarg_hr_util_pkg.debug(gv_debug_mode
                                    ,gv_pkg_name || '.pop_empl_timecard', 30);

            -- Set Holiday count to ZERO
            ln_hol_cnt := 0;

            -- Create Holiday TimeCard
            -- Get Holiday Calendar
            lv_hol_cldr := null;
            ln_hol_cldr_id := null;
            open c_get_hol_cldr(vc_get_emp_wagarg.assignment_id
                               ,gd_w1_end);
            fetch c_get_hol_cldr into lv_hol_cldr
                                     ,ln_hol_cldr_id;
            close c_get_hol_cldr;

            if lv_hol_cldr is null then
               lv_hol_cldr := 'WAG Holiday Calendar';
            end if;

            -- Set Time Entry Start date to Week Start Date
            ld_week_start := gd_w1_start;

            -- Check if Employee Started after Week Start Date
            -- In that case, we have to start creating Time Entry only after
            -- his start date as system will not allow Time Entries to
            -- be created before the Employees Start Date
            if vc_get_emp_wagarg.date_start > gd_w1_start then
               ld_week_start := vc_get_emp_wagarg.date_start;
            end if;

            -- Setting Current Time Entry Date to Start Date
            ld_cur_te_date := ld_week_start;

            -- Loop through Holidays based on Employees Holiday calendar
            -- The dates used here are actual dates for which we have to create
            -- the Time Entry
            open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                   ,ld_cur_te_date
                                   ,gd_w1_end);
            loop
               fetch c_get_hol_cnt_cldr into ld_hol_date;
               exit when c_get_hol_cnt_cldr%NOTFOUND;

               -- Increment Holiday Count for calculation of normal hours
               -- later in the code
               ln_hol_cnt := ln_hol_cnt + 1;

               -- Create Time Entry for Holiday
               create_timecard(vc_get_emp_wagarg.person_id
                              ,vc_get_emp_wagarg.employee_number
                              ,ln_norm_hours/5
                              ,ln_hol_ele_type_id
                              ,ld_hol_date
                              ,vc_get_emp_wagarg.pay_basis_id);

            end loop;
            close c_get_hol_cnt_cldr;

            -- Before creating Time entry for Time Entry Wages, we need to
            -- check whether the employee's work location is 'CA'.
            -- If YES
            --    We need to create individual Time Entries
            -- If NO
            --    We need to create a SINGLE Time Entry at the end of the
            --    period
            if lv_state in ('CA', 'CO') then

               xxarg_hr_util_pkg.debug(gv_debug_mode
                                      ,gv_pkg_name || '.pop_empl_timecard', 40);


               loop
                  -- Check if the day is Sunday or Saturday. In which case
                  -- we do not create any Time Entry
                  if trim(to_char(ld_cur_te_date,'DAY')) not in
                          ('SATURDAY','SUNDAY') then

                     if ln_hol_cnt > 0 then
                        -- A Holiday entry was created before. We need to make
                        -- sure that we do not create a Time Entry for Time
                        -- Entry Wages on Holida
                        open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                               ,ld_cur_te_date
                                               ,ld_cur_te_date);
                        fetch c_get_hol_cnt_cldr into ld_hol_date;
                        -- If the date is not a Holiday, then create the Time
                        -- Entry
                        if c_get_hol_cnt_cldr%NOTFOUND then
                           create_timecard(vc_get_emp_wagarg.person_id
                                          ,vc_get_emp_wagarg.employee_number
                                          ,ln_norm_hours/5
                                          ,ln_reg_ele_type_id
                                          ,ld_cur_te_date
                                          ,vc_get_emp_wagarg.pay_basis_id);
                        end if; -- if c_get_hol_cnt_cldr%NOTFOUND
                        close c_get_hol_cnt_cldr;
                     else
                        -- Create Time Entry for Time Entry Wages
                        create_timecard(vc_get_emp_wagarg.person_id
                                       ,vc_get_emp_wagarg.employee_number
                                       ,ln_norm_hours/5
                                       ,ln_reg_ele_type_id
                                       ,ld_cur_te_date
                                       ,vc_get_emp_wagarg.pay_basis_id);
                     end if;
                  end if; -- if to_char(ld_cur_te_date,'DAY')

                  -- Increment Current Date
                  ld_cur_te_date := ld_cur_te_date + 1;

                  -- Check if Current Date >= Week End Date... Exit Condition
                  exit when ld_cur_te_date >= gd_w1_end;
               end loop;
            else
               -- Create a SINGLE Time Entry at the end of the period
               -- Calculate Holiday Hours based on weekly NORMAL HOURS
               ln_hol_hours := (ln_hol_cnt/5) * ln_norm_hours;

               -- Calculate the Actual Time Entry Hours
               ln_te_hours := ln_norm_hours - ln_hol_hours;

               -- Create Time Entry for Time Entry Wages
               create_timecard(vc_get_emp_wagarg.person_id
                              ,vc_get_emp_wagarg.employee_number
                              ,ln_te_hours
                              ,ln_reg_ele_type_id
                              ,gd_w1_end
                              ,vc_get_emp_wagarg.pay_basis_id);
            end if; -- if lv_state = 'CA'
         end if; -- if c_get_emp_nh%FOUND
         close c_get_emp_nh;

         -- Execute Deposit for Week 1
         EXECUTE_DEPOSIT(vc_get_emp_wagarg.employee_number
                        ,gd_w1_end);

         -- Insert into TIME Source table for keeping track of employees
         -- whose Timecard has been loaded
         INS_INTO_TC_SOURCE('PRELOAD'
                           ,vc_get_emp_wagarg.person_id
                           ,gd_w1_end);

         -- Week2 Timecard starts here
         if gd_w2_start is not null and gd_w2_end is not null then
            -- Fetch Normal hours for Week2 and check whether Assignment is
            -- eligible for Time Entry for Week2
            -- The check is done in the cursor
            xxarg_hr_util_pkg.debug(gv_debug_mode
                                   ,gv_pkg_name || '.pop_empl_timecard', 50);

            open c_get_emp_nh(vc_get_emp_wagarg.assignment_id
                             ,gd_w2_end);
            fetch c_get_emp_nh into ln_norm_hours
                                   ,lv_state;
            if c_get_emp_nh%FOUND then

               -- Set Holiday count to ZERO
               ln_hol_cnt := 0;

               -- Create Holiday TimeCard
               -- Get Holiday Calendar
               lv_hol_cldr := null;
               ln_hol_cldr_id := null;
               open c_get_hol_cldr(vc_get_emp_wagarg.assignment_id
                                  ,gd_w2_end);
               fetch c_get_hol_cldr into lv_hol_cldr
                                        ,ln_hol_cldr_id;
               close c_get_hol_cldr;

               if lv_hol_cldr is null then
                  lv_hol_cldr := 'WAG Holiday Calendar';
               end if;

               -- Set Time Entry Start date to Week Start Date
               ld_week_start := gd_w2_start;

               -- Check if Employee Started after Week Start Date
               -- In that case, we have to start creating Time Entry only after
               -- his start date as system will not allow Time Entries to
               -- be created before the Employees Start Date
               if vc_get_emp_wagarg.date_start > gd_w2_start then
                  ld_week_start := vc_get_emp_wagarg.date_start;
               end if;

               -- Setting Current Time Entry Date to Start Date
               ld_cur_te_date := ld_week_start;

               -- Loop through Holidays based on Employees Holiday calendar
               -- The dates used here are actual dates for which we have to create
               -- the Time Entry
               open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                      ,ld_cur_te_date
                                      ,gd_w2_end);
               loop
                  fetch c_get_hol_cnt_cldr into ld_hol_date;
                  exit when c_get_hol_cnt_cldr%NOTFOUND;
                  ln_hol_cnt := ln_hol_cnt + 1;

                  -- Create Time Entry for Holiday
                  create_timecard(vc_get_emp_wagarg.person_id
                                 ,vc_get_emp_wagarg.employee_number
                                 ,ln_norm_hours/5
                                 ,ln_hol_ele_type_id
                                 ,ld_hol_date
                                 ,vc_get_emp_wagarg.pay_basis_id);

               end loop;
               close c_get_hol_cnt_cldr;

               -- Before creating Time entry for Time Entry Wages, we need to
               -- check whether the employee's work location is 'CA'.
               -- If YES
               --    We need to create individual Time Entries
               -- If NO
               --    We need to create a SINGLE Time Entry at the end of the
               --    period
               if lv_state in ('CA','CO') then

                   xxarg_hr_util_pkg.debug(gv_debug_mode
                                          ,gv_pkg_name || '.pop_empl_timecard', 60);

                  loop
                     -- Check if the day is Sunday or Saturday. In which case
                     -- we do not create any Time Entry
                     if trim(to_char(ld_cur_te_date,'DAY')) not in
                             ('SATURDAY','SUNDAY') then
                        if ln_hol_cnt > 0 then
                           -- A Holiday entry was created before. We need to make
                           -- sure that we do not create a Time Entry for Time
                           -- Entry Wages on Holidays
                           open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                                  ,ld_cur_te_date
                                                  ,ld_cur_te_date);
                           fetch c_get_hol_cnt_cldr into ld_hol_date;
                           -- If the date is not a Holiday, then create the Time
                           -- Entry
                           if c_get_hol_cnt_cldr%NOTFOUND then
                              create_timecard(vc_get_emp_wagarg.person_id
                                             ,vc_get_emp_wagarg.employee_number
                                             ,ln_norm_hours/5
                                             ,ln_reg_ele_type_id
                                             ,ld_cur_te_date
                                             ,vc_get_emp_wagarg.pay_basis_id);
                           end if; -- if c_get_hol_cnt_cldr%NOTFOUND
                           close c_get_hol_cnt_cldr;
                        else
                           -- Create Time Entry for Time Entry Wages
                           create_timecard(vc_get_emp_wagarg.person_id
                                          ,vc_get_emp_wagarg.employee_number
                                          ,ln_norm_hours/5
                                          ,ln_reg_ele_type_id
                                          ,ld_cur_te_date
                                          ,vc_get_emp_wagarg.pay_basis_id);
                        end if;
                     end if; -- if to_char(ld_cur_te_date,'DAY')

                     -- Increment Current Date
                     ld_cur_te_date := ld_cur_te_date + 1;

                     -- Check if Current Date >= Week End Date... Exit Condition
                     exit when ld_cur_te_date >= gd_w2_end;
                  end loop;
               else
                  -- Create a SINGLE Time Entry at the end of the period
                  -- Calculate Holiday Hours based on weekly NORMAL HOURS
                  ln_hol_hours := (ln_hol_cnt/5) * ln_norm_hours;

                  -- Calculate the Actual Time Entry Hours
                  ln_te_hours := ln_norm_hours - ln_hol_hours;

                  -- Create Time Entry for Holiday
                  create_timecard(vc_get_emp_wagarg.person_id
                                 ,vc_get_emp_wagarg.employee_number
                                 ,ln_te_hours
                                 ,ln_reg_ele_type_id
                                 ,gd_w2_end
                                 ,vc_get_emp_wagarg.pay_basis_id);
               end if;
            end if; -- if c_get_emp_nh%FOUND
            close c_get_emp_nh;

            -- Execute Deposit for Week 2
            EXECUTE_DEPOSIT(vc_get_emp_wagarg.employee_number
                          ,gd_w2_end);
            
            -- Insert into TIME Source table for keeping track of employees
            -- whose Timecard has been loaded
            INS_INTO_TC_SOURCE('PRELOAD'
                              ,vc_get_emp_wagarg.person_id
                              ,gd_w2_end);

         end if; -- if gd_w2_start is


      end loop WAGARG_EMP_LOOP;
      close c_get_emp_wagarg;

      xxarg_hr_util_pkg.debug(gv_debug_mode
                             ,gv_pkg_name || '.pop_empl_timecard', 40);

   elsif p_bus_grp_id = 0 then
      -- US Business Group
      -- Fetch Element Type ID for Time Entry Wages
      -- This element type id is further used in creating Timecards
      select element_type_id
        into ln_reg_ele_type_id
        from pay_element_types_f
       where element_name = 'REG'
         and business_group_id = p_bus_grp_id
         and trunc(sysdate) between effective_start_date
                                and effective_end_date;

      -- Fetch Element Type ID for Holiday(US)
      -- This element type id is further used in creating Timecards
      select element_type_id
        into ln_hol_ele_type_id
        from pay_element_types_f
       where element_name = 'HOL'
         and business_group_id = p_bus_grp_id
         and trunc(sysdate) between effective_start_date
                                and effective_end_date;

      xxarg_hr_util_pkg.debug(gv_debug_mode
                             ,gv_pkg_name || '.pop_empl_timecard', 70);

      -- Fetch all employees for whome Timecard has to be loaded
      open c_get_emp_us_oth(p_pay_id
                           ,gd_pd_start + 6
                           ,gd_pd_end);
      <<US_EMP_LOOP>>
      loop

         fetch c_get_emp_us_oth into vc_get_emp_us_oth;
         exit when c_get_emp_us_oth%notfound;

         -- Week1 Timecard starts here
         -- Fetch Normal hours for Week1 and check whether Assignment is
         -- eligible for Time Entry for Week1
         -- The check is done in the cursor c_get_emp_nh
         open c_get_emp_nh(vc_get_emp_us_oth.assignment_id
                          ,gd_w1_end);
         fetch c_get_emp_nh into ln_norm_hours
                                ,lv_state;
         if c_get_emp_nh%FOUND then
         
           xxarg_hr_util_pkg.debug(gv_debug_mode
                                  ,gv_pkg_name || '.pop_empl_timecard', 80);


            -- Set Holiday count to ZERO
            ln_hol_cnt := 0;

            -- Create Holiday TimeCard
            -- Get Holiday Calendar
            lv_hol_cldr := null;
            ln_hol_cldr_id := null;
            open c_get_hol_cldr(vc_get_emp_us_oth.assignment_id
                               ,gd_w1_end);
            fetch c_get_hol_cldr into lv_hol_cldr
                                     ,ln_hol_cldr_id;
            close c_get_hol_cldr;

            if lv_hol_cldr is null then
               lv_hol_cldr := 'WAG Holiday Calendar';
            end if;

            -- Set Time Entry Start date to Week Start Date
            ld_week_start := gd_w1_start;

            -- Check if Employee Started after Week Start Date
            -- In that case, we have to start creating Time Entry only after
            -- his start date as system will not allow Time Entries to
            -- be created before the Employees Start Date
            if vc_get_emp_us_oth.date_start > gd_w1_start then
               ld_week_start := vc_get_emp_us_oth.date_start;
            end if;

            -- Setting Current Time Entry Date to Start Date
            ld_cur_te_date := ld_week_start;

            -- Loop through Holidays based on Employees Holiday calendar
            -- The dates used here are actual dates for which we have to create
            -- the Time Entry
            open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                   ,ld_cur_te_date
                                   ,gd_w1_end);
            loop
               fetch c_get_hol_cnt_cldr into ld_hol_date;
               exit when c_get_hol_cnt_cldr%NOTFOUND;

               -- Increment Holiday Count for calculation of normal hours
               -- later in the code
               ln_hol_cnt := ln_hol_cnt + 1;

               -- Create Time Entry for Holiday
               create_timecard(vc_get_emp_us_oth.person_id
                              ,vc_get_emp_us_oth.employee_number
                              ,ln_norm_hours/5
                              ,ln_hol_ele_type_id
                              ,ld_hol_date
                              ,vc_get_emp_us_oth.pay_basis_id);

            end loop;
            close c_get_hol_cnt_cldr;

            -- Before creating Time entry for Time Entry Wages, we need to
            -- check whether the employee's work location is 'CA'.
            -- If YES
            --    We need to create individual Time Entries
            -- If NO
            --    We need to create a SINGLE Time Entry at the end of the
            --    period
            if lv_state in ('CA','CO') then

               xxarg_hr_util_pkg.debug(gv_debug_mode
                             ,gv_pkg_name || '.pop_empl_timecard', 90);

               loop
                  -- Check if the day is Sunday or Saturday. In which case
                  -- we do not create any Time Entry
                  if trim(to_char(ld_cur_te_date,'DAY')) not in
                          ('SATURDAY','SUNDAY') then
                     if ln_hol_cnt > 0 then
                        -- A Holiday entry was created before. We need to make
                        -- sure that we do not create a Time Entry for Time
                        -- Entry Wages on Holida
                        open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                               ,ld_cur_te_date
                                               ,ld_cur_te_date);
                        fetch c_get_hol_cnt_cldr into ld_hol_date;
                        -- If the date is not a Holiday, then create the Time
                        -- Entry
                        if c_get_hol_cnt_cldr%NOTFOUND then
                           create_timecard(vc_get_emp_us_oth.person_id
                                          ,vc_get_emp_us_oth.employee_number
                                          ,ln_norm_hours/5
                                          ,ln_reg_ele_type_id
                                          ,ld_cur_te_date
                                          ,vc_get_emp_us_oth.pay_basis_id);
                        end if; -- if c_get_hol_cnt_cldr%NOTFOUND
                        close c_get_hol_cnt_cldr;
                     else
                        -- Create Time Entry for Time Entry Wages
                        create_timecard(vc_get_emp_us_oth.person_id
                                       ,vc_get_emp_us_oth.employee_number
                                       ,ln_norm_hours/5
                                       ,ln_reg_ele_type_id
                                       ,ld_cur_te_date
                                       ,vc_get_emp_us_oth.pay_basis_id);
                     end if; -- if ln_hol_cnt > 0 then
                  end if; -- if to_char(ld_cur_te_date,'DAY')

                  -- Increment Current Date
                  ld_cur_te_date := ld_cur_te_date + 1;

                  -- Check if Current Date >= Week End Date... Exit Condition
                  exit when ld_cur_te_date >= gd_w1_end;
               end loop;
            else
               -- Create a SINGLE Time Entry at the end of the period
               -- Calculate Holiday Hours based on weekly NORMAL HOURS
               ln_hol_hours := (ln_hol_cnt/5) * ln_norm_hours;

               -- Calculate the Actual Time Entry Hours
               ln_te_hours := ln_norm_hours - ln_hol_hours;

               -- Create Time Entry for Time Entry Wages
               create_timecard(vc_get_emp_us_oth.person_id
                              ,vc_get_emp_us_oth.employee_number
                              ,ln_te_hours
                              ,ln_reg_ele_type_id
                              ,gd_w1_end
                              ,vc_get_emp_us_oth.pay_basis_id);
            end if; -- if lv_state = 'CA'
         end if; -- if c_get_emp_nh%FOUND
         close c_get_emp_nh;

         -- Execute Deposit for Week 1
         EXECUTE_DEPOSIT(vc_get_emp_us_oth.employee_number
                        ,gd_w1_end);

         -- Insert into TIME Source table for keeping track of employees
         -- whose Timecard has been loaded
         INS_INTO_TC_SOURCE('PRELOAD'
                           ,vc_get_emp_us_oth.person_id
                           ,gd_w1_end);

         -- Week2 Timecard starts here
         if gd_w2_start is not null and gd_w2_end is not null then

            xxarg_hr_util_pkg.debug(gv_debug_mode
                                   ,gv_pkg_name || '.pop_empl_timecard', 100);

            -- Fetch Normal hours for Week2 and check whether Assignment is
            -- eligible for Time Entry for Week2
            -- The check is done in the cursor
            open c_get_emp_nh(vc_get_emp_us_oth.assignment_id
                             ,gd_w2_end);
            fetch c_get_emp_nh into ln_norm_hours
                                   ,lv_state;
            if c_get_emp_nh%FOUND then

               -- Set Holiday count to ZERO
               ln_hol_cnt := 0;

               -- Create Holiday TimeCard
               -- Get Holiday Calendar
               lv_hol_cldr := null;
               ln_hol_cldr_id := null;
               open c_get_hol_cldr(vc_get_emp_us_oth.assignment_id
                                  ,gd_w2_end);
               fetch c_get_hol_cldr into lv_hol_cldr
                                        ,ln_hol_cldr_id;
               close c_get_hol_cldr;

               if lv_hol_cldr is null then
                  lv_hol_cldr := 'WAG Holiday Calendar';
               end if;

               -- Set Time Entry Start date to Week Start Date
               ld_week_start := gd_w2_start;

               -- Check if Employee Started after Week Start Date
               -- In that case, we have to start creating Time Entry only after
               -- his start date as system will not allow Time Entries to
               -- be created before the Employees Start Date
               if vc_get_emp_us_oth.date_start > gd_w2_start then
                  ld_week_start := vc_get_emp_us_oth.date_start;
               end if;

               -- Setting Current Time Entry Date to Start Date
               ld_cur_te_date := ld_week_start;

               -- Loop through Holidays based on Employees Holiday calendar
               -- The dates used here are actual dates for which we have to create
               -- the Time Entry
               open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                      ,ld_cur_te_date
                                      ,gd_w2_end);
               loop
                  fetch c_get_hol_cnt_cldr into ld_hol_date;
                  exit when c_get_hol_cnt_cldr%NOTFOUND;
                  ln_hol_cnt := ln_hol_cnt + 1;

                  -- Create Time Entry for Holiday
                  create_timecard(vc_get_emp_us_oth.person_id
                                 ,vc_get_emp_us_oth.employee_number
                                 ,ln_norm_hours/5
                                 ,ln_hol_ele_type_id
                                 ,ld_hol_date
                                 ,vc_get_emp_us_oth.pay_basis_id);

               end loop;
               close c_get_hol_cnt_cldr;

               -- Before creating Time entry for Time Entry Wages, we need to
               -- check whether the employee's work location is 'CA'.
               -- If YES
               --    We need to create individual Time Entries
               -- If NO
               --    We need to create a SINGLE Time Entry at the end of the
               --    period
               if lv_state in ('CA','CO') then
                  loop
                     -- Check if the day is Sunday or Saturday. In which case
                     -- we do not create any Time Entry
                     if trim(to_char(ld_cur_te_date,'DAY')) not in
                             ('SATURDAY','SUNDAY') then
                        if ln_hol_cnt > 0 then
                           -- A Holiday entry was created before. We need to make
                           -- sure that we do not create a Time Entry for Time
                           -- Entry Wages on Holida
                           open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                                  ,ld_cur_te_date
                                                  ,ld_cur_te_date);
                           fetch c_get_hol_cnt_cldr into ld_hol_date;
                           -- If the date is not a Holiday, then create the Time
                           -- Entry
                           if c_get_hol_cnt_cldr%NOTFOUND then
                              create_timecard(vc_get_emp_us_oth.person_id
                                             ,vc_get_emp_us_oth.employee_number
                                             ,ln_norm_hours/5
                                             ,ln_reg_ele_type_id
                                             ,ld_cur_te_date
                                             ,vc_get_emp_us_oth.pay_basis_id);
                           end if; -- if c_get_hol_cnt_cldr%NOTFOUND
                           close c_get_hol_cnt_cldr;
                        else
                           -- Create Time Entry for Time Entry Wages
                           create_timecard(vc_get_emp_us_oth.person_id
                                          ,vc_get_emp_us_oth.employee_number
                                          ,ln_norm_hours/5
                                          ,ln_reg_ele_type_id
                                          ,ld_cur_te_date
                                          ,vc_get_emp_us_oth.pay_basis_id);
                        end if; -- if ln_hol_cnt > 0 then
                     end if; -- if to_char(ld_cur_te_date,'DAY')

                     -- Increment Current Date
                     ld_cur_te_date := ld_cur_te_date + 1;

                     -- Check if Current Date >= Week End Date... Exit Condition
                     exit when ld_cur_te_date >= gd_w2_end;
                  end loop;

               else
                  -- Create a SINGLE Time Entry at the end of the period
                  -- Calculate Holiday Hours based on weekly NORMAL HOURS
                  ln_hol_hours := (ln_hol_cnt/5) * ln_norm_hours;

                  -- Calculate the Actual Time Entry Hours
                  ln_te_hours := ln_norm_hours - ln_hol_hours;

                  -- Create Time Entry for Holiday
                  create_timecard(vc_get_emp_us_oth.person_id
                                 ,vc_get_emp_us_oth.employee_number
                                 ,ln_te_hours
                                 ,ln_reg_ele_type_id
                                 ,gd_w2_end
                                 ,vc_get_emp_us_oth.pay_basis_id);
               end if;
            end if; -- if c_get_emp_nh%FOUND
            close c_get_emp_nh;

            -- Execute Deposit for Week 2
            EXECUTE_DEPOSIT(vc_get_emp_us_oth.employee_number
                           ,gd_w2_end);

            -- Insert into TIME Source table for keeping track of employees
            -- whose Timecard has been loaded
            INS_INTO_TC_SOURCE('PRELOAD'
                              ,vc_get_emp_us_oth.person_id
                              ,gd_pd_end);
         end if; -- if gd_w2_start is

      end loop US_EMP_LOOP;
      close c_get_emp_us_oth;

      xxarg_hr_util_pkg.debug(gv_debug_mode
                             ,gv_pkg_name || '.pop_empl_timecard', 40);

   else
      -- CA Business Group
      -- Fetch Element Type ID for Time Entry Wages
      -- This element type id is further used in creating Timecards
      select element_type_id
        into ln_reg_ele_type_id
        from pay_element_types_f
       where element_name = 'REG'
         and business_group_id = p_bus_grp_id
         and trunc(sysdate) between effective_start_date
                                and effective_end_date;

      -- Fetch Element Type ID for Holiday(CA)
      -- This element type id is further used in creating Timecards
      select element_type_id
        into ln_hol_ele_type_id
        from pay_element_types_f
       where element_name = 'HOL'
         and business_group_id = p_bus_grp_id
         and trunc(sysdate) between effective_start_date
                                and effective_end_date;

      -- Fetch Element Type ID for Laudnry Wages(CA)
      -- This element type id is further used in creating Timecards
      select element_type_id
        into ln_ldr_ele_type_id
        from pay_element_types_f
       where element_name = 'LAN'
         and business_group_id = p_bus_grp_id
         and trunc(sysdate) between effective_start_date
                                and effective_end_date;


      xxarg_hr_util_pkg.debug(gv_debug_mode
                             ,gv_pkg_name || '.pop_empl_timecard', 110);

      -- Fetch all employees for whome Timecard has to be loaded
      open c_get_emp_ca(p_pay_id
                       ,gd_pd_start + 6
                       ,gd_pd_end);
      <<CA_EMP_LOOP>>
      loop

         fetch c_get_emp_ca into vc_get_emp_ca;
         exit when c_get_emp_ca%notfound;
         -- Week1 Timecard starts here
         -- Fetch Normal hours for Week1 and check whether Assignment is
         -- eligible for Time Entry for Week1
         open c_get_emp_nh_ca(vc_get_emp_ca.assignment_id
                             ,gd_w1_end);
         fetch c_get_emp_nh_ca into ln_norm_hours
                                   ,lv_prov;
         if c_get_emp_nh_ca%FOUND then
         
            xxarg_hr_util_pkg.debug(gv_debug_mode
                                   ,gv_pkg_name || '.pop_empl_timecard', 120);


            -- Set Holiday count to ZERO
            ln_hol_cnt := 0;

            -- Create Holiday TimeCard
            -- Get Holiday Calendar
            lv_hol_cldr := null;
            ln_hol_cldr_id := null;
            open c_get_hol_cldr(vc_get_emp_ca.assignment_id
                               ,gd_w1_end);
            fetch c_get_hol_cldr into lv_hol_cldr
                                     ,ln_hol_cldr_id;
            close c_get_hol_cldr;

            -- Set Time Entry Start date to Week Start Date
            ld_week_start := gd_w1_start;

            -- Check if Employee Started after Week Start Date
            -- In that case, we have to start creating Time Entry only after
            -- his start date as system will not allow Time Entries to
            -- be created before the Employees Start Date
            if vc_get_emp_ca.date_start > gd_w1_start then
               ld_week_start := vc_get_emp_ca.date_start;
            end if;

            -- Setting Current Time Entry Date to Start Date
            ld_cur_te_date := ld_week_start;

            -- Loop through Holidays based on Employees Holiday calendar
            -- The dates used here are actual dates for which we have to create
            -- the Time Entry
            open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                   ,ld_cur_te_date
                                   ,gd_w1_end);
            loop
               fetch c_get_hol_cnt_cldr into ld_hol_date;
               exit when c_get_hol_cnt_cldr%NOTFOUND;

               -- Increment Holiday Count for calculation of normal hours
               -- later in the code
               ln_hol_cnt := ln_hol_cnt + 1;

               -- Create Time Entry for Holiday
               create_timecard(vc_get_emp_ca.person_id
                              ,vc_get_emp_ca.employee_number
                              ,ln_norm_hours/5
                              ,ln_hol_ele_type_id
                              ,ld_hol_date
                              ,vc_get_emp_ca.pay_basis_id);
            end loop;
            close c_get_hol_cnt_cldr;
---------------------------------------------------

            xxarg_hr_util_pkg.debug(gv_debug_mode
                                   ,gv_pkg_name || '.pop_empl_timecard', 130);

            loop
               -- Check if the day is Sunday or Saturday. In which case
               -- we do not create any Time Entry
               if trim(to_char(ld_cur_te_date,'DAY')) not in
                       ('SATURDAY','SUNDAY') then
                  if ln_hol_cnt > 0 then
                     -- A Holiday entry was created before. We need to make
                     -- sure that we do not create a Time Entry for Time
                     -- Entry Wages on Holiday
                     open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                            ,ld_cur_te_date
                                            ,ld_cur_te_date);
                     fetch c_get_hol_cnt_cldr into ld_hol_date;
                     -- If the date is not a Holiday, then create the Time
                     -- Entry
                     if c_get_hol_cnt_cldr%NOTFOUND then
                        create_timecard(vc_get_emp_ca.person_id
                                       ,vc_get_emp_ca.employee_number
                                       ,ln_norm_hours/5
                                       ,ln_reg_ele_type_id
                                       ,ld_cur_te_date
                                       ,vc_get_emp_ca.pay_basis_id);
                     end if; -- if c_get_hol_cnt_cldr%NOTFOUND
                     close c_get_hol_cnt_cldr;
                  else
                     -- Create Time Entry for Time Entry Wages
                     create_timecard(vc_get_emp_ca.person_id
                                    ,vc_get_emp_ca.employee_number
                                    ,ln_norm_hours/5
                                    ,ln_reg_ele_type_id
                                    ,ld_cur_te_date
                                    ,vc_get_emp_ca.pay_basis_id);
                  end if; -- if ln_hol_cnt > 0 then
               end if; -- if to_char(ld_cur_te_date,'DAY')

               -- Increment Current Date
               ld_cur_te_date := ld_cur_te_date + 1;

               -- Check if Current Date >= Week End Date... Exit Condition
               exit when ld_cur_te_date >= gd_w1_end;
            end loop;

         end if; -- if c_get_emp_nh%FOUND
         close c_get_emp_nh_ca;

         -- Execute Deposit for Week 1
         EXECUTE_DEPOSIT(vc_get_emp_ca.employee_number
                        ,gd_w1_end);

         -- Insert into TIME Source table for keeping track of employees
         -- whose Timecard has been loaded
         INS_INTO_TC_SOURCE('PRELOAD'
                           ,vc_get_emp_ca.person_id
                           ,gd_w1_end);

         -- Week2 Timecard starts here
         if gd_w2_start is not null and gd_w2_end is not null then

            xxarg_hr_util_pkg.debug(gv_debug_mode
                                   ,gv_pkg_name || '.pop_empl_timecard', 140);

            -- Fetch Normal hours for Week1 and check whether Assignment is
            -- eligible for Time Entry for Week1
            open c_get_emp_nh_ca(vc_get_emp_ca.assignment_id
                                ,gd_w2_end);
            fetch c_get_emp_nh_ca into ln_norm_hours
                                      ,lv_prov;
            if c_get_emp_nh_ca%FOUND then
               -- Set Holiday count to ZERO
               ln_hol_cnt := 0;

               -- Create Holiday TimeCard
               -- Get Holiday Calendar
               lv_hol_cldr := null;
               ln_hol_cldr_id := null;
               open c_get_hol_cldr(vc_get_emp_ca.assignment_id
                                  ,gd_w2_end);
               fetch c_get_hol_cldr into lv_hol_cldr
                                        ,ln_hol_cldr_id;
               close c_get_hol_cldr;

               -- Set Time Entry Start date to Week Start Date
               ld_week_start := gd_w2_start;

               -- Check if Employee Started after Week Start Date
               -- In that case, we have to start creating Time Entry only after
               -- his start date as system will not allow Time Entries to
               -- be created before the Employees Start Date
               if vc_get_emp_ca.date_start > gd_w2_start then
                  ld_week_start := vc_get_emp_ca.date_start;
               end if;

              -- Setting Current Time Entry Date to Start Date
               ld_cur_te_date := ld_week_start;

               -- Loop through Holidays based on Employees Holiday calendar
               -- The dates used here are actual dates for which we have to create
               -- the Time Entry
               open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                      ,ld_cur_te_date
                                      ,gd_w2_end);
               loop
                  fetch c_get_hol_cnt_cldr into ld_hol_date;
                  exit when c_get_hol_cnt_cldr%NOTFOUND;

                  -- Increment Holiday Count for calculation of normal hours
                  -- later in the code
                  ln_hol_cnt := ln_hol_cnt + 1;

                  -- Create Time Entry for Holiday
                  create_timecard(vc_get_emp_ca.person_id
                                 ,vc_get_emp_ca.employee_number
                                 ,ln_norm_hours/5
                                 ,ln_hol_ele_type_id
                                 ,ld_hol_date
                                 ,vc_get_emp_ca.pay_basis_id);

               end loop;
               close c_get_hol_cnt_cldr;

-----------------------------------------------
               loop
                  -- Check if the day is Sunday or Saturday. In which case
                  -- we do not create any Time Entry
                  if trim(to_char(ld_cur_te_date,'DAY')) not in
                          ('SATURDAY','SUNDAY') then
                     if ln_hol_cnt > 0 then
                        -- A Holiday entry was created before. We need to make
                        -- sure that we do not create a Time Entry for Time
                        -- Entry Wages on Holiday
                        open c_get_hol_cnt_cldr(ln_hol_cldr_id
                                               ,ld_cur_te_date
                                               ,ld_cur_te_date);
                        fetch c_get_hol_cnt_cldr into ld_hol_date;
                        -- If the date is not a Holiday, then create the Time
                        -- Entry
                        if c_get_hol_cnt_cldr%NOTFOUND then
                           create_timecard(vc_get_emp_ca.person_id
                                          ,vc_get_emp_ca.employee_number
                                          ,ln_norm_hours/5
                                          ,ln_reg_ele_type_id
                                          ,ld_cur_te_date
                                          ,vc_get_emp_ca.pay_basis_id);
                        end if; -- if c_get_hol_cnt_cldr%NOTFOUND
                        close c_get_hol_cnt_cldr;
                     else
                        -- Create Time Entry for Time Entry Wages
                        create_timecard(vc_get_emp_ca.person_id
                                       ,vc_get_emp_ca.employee_number
                                       ,ln_norm_hours/5
                                       ,ln_reg_ele_type_id
                                       ,ld_cur_te_date
                                       ,vc_get_emp_ca.pay_basis_id);
                     end if; -- if ln_hol_cnt > 0 then
                  end if; -- if to_char(ld_cur_te_date,'DAY')

                  -- Increment Current Date
                  ld_cur_te_date := ld_cur_te_date + 1;

                  -- Check if Current Date >= Week End Date... Exit Condition
                  exit when ld_cur_te_date >= gd_w2_end;
               end loop;
            end if; -- if c_get_emp_nh%FOUND
            close c_get_emp_nh_ca;
         end if; -- if gd_w2_start is

         EXECUTE_DEPOSIT(vc_get_emp_ca.employee_number
                       ,gd_w2_end);

         -- Insert into TIME Source table for keeping track of employees
         -- whose Timecard has been loaded
         INS_INTO_TC_SOURCE('PRELOAD'
                           ,vc_get_emp_ca.person_id
                           ,gd_w2_end);


      end loop CA_EMP_LOOP;

      close c_get_emp_ca;


      xxarg_hr_util_pkg.debug(gv_debug_mode
                             ,gv_pkg_name || '.pop_empl_timecard', 180);
   end if;

   xxarg_hr_util_pkg.debug(gv_debug_mode
                      ,'Leaving ' || gv_pkg_name || '.pop_empl_timecard', 60);

END POP_EMPL_TIMECARD;

/*******************************************************************************
   Name         :  PRELOAD
   Description  :  Preload Oracle timecard data for all Salaried employees
*******************************************************************************/
PROCEDURE PRELOAD(errbuf    OUT VARCHAR2
                 ,retcode   OUT VARCHAR2
                 ,p_payroll  IN NUMBER) is

-- Cursor to get Payroll Name, Period Type and Business Group ID
cursor c_get_pay(cp_payroll_id number) is
select payroll_name
      ,period_type
      ,business_group_id
 from pay_all_payrolls_f
where payroll_id = cp_payroll_id
  and trunc(sysdate) between effective_start_date
                         and effective_end_date;

-- Cutsor to get the Max Row flag for the payroll passed in
cursor c_get_max_row_flag(cp_payroll_id number) is
select payroll_run
      ,period_end_date
  from XXARG.XXARG_HR_OTL_CTRL_TBL
 where payroll_id = cp_payroll_id
 order by period_end_date desc;

-- Cursor to get Next period end dates
cursor c_get_next_pd_dates(cp_payroll_id number
                          ,cp_date       date) is
select start_date
      ,end_date
  from per_time_periods
 where payroll_id = cp_payroll_id
   and cp_date + 1 between start_date
                       and end_date;

  lv_payroll_name varchar2(30);
  lv_period_type  varchar2(30);
  lv_flag         varchar2(10);

  ln_payroll_id   number;
  ln_bus_grp_id   number;

  ld_pdate        date;
  ld_last_pd_end  date;

BEGIN

/*   xxarg_hr_util_pkg.debug(gv_debug_mode
                          ,'Entering ' || gv_pkg_name || '.preload', 10); */

   -- Initializing Variables
   ln_payroll_id := p_payroll;
   gd_pd_start   := null;
   gd_pd_end     := null;
   gd_w1_start   := null;
   gd_w1_end     := null;
   gd_w2_start   := null;
   gd_w2_end     := null;

   -- Check whether the latest row in the Control table has its Payroll run
   -- flag set to 'Y'
   -- If FLAG is set to 'Y' then
   --    Insert a row for the next period and populate the timecard entry
   --    for next period
   -- If Flag is set to 'N' then
   --    Payroll has not yet been run for the already populated timecard
   --    Skip preloading timecard
   open c_get_max_row_flag(ln_payroll_id);
   fetch c_get_max_row_flag into lv_flag
                                ,ld_last_pd_end;
   close c_get_max_row_flag;

   -- Check whether the Payroll Run FLAG is set to 'Y'
   if lv_flag = 'Y' then
      -- Get Payroll Name, Type and Business Group ID
      open c_get_pay(ln_payroll_id);
      fetch c_get_pay into lv_payroll_name
                          ,lv_period_type
                          ,ln_bus_grp_id;
      close c_get_pay;

      -- Get the next period start date and end date based on the last
      -- processed payroll period end date
      open c_get_next_pd_dates(ln_payroll_id
                              ,ld_last_pd_end);
      fetch c_get_next_pd_dates into gd_pd_start
                                    ,gd_pd_end;
      close c_get_next_pd_dates;

      -- Calculate Week1 and Week2 dates
      -- Assumption :
      --    All payrolls in Wendys/Arbys group will be either Biweekly
      --    or Weekly
      if lv_period_type = 'Week' then
         gd_w1_start := gd_pd_start;
         gd_w1_end   := gd_pd_end;
      else
         gd_w1_start := gd_pd_start;
         gd_w1_end   := gd_pd_start + 6;
         gd_w2_start := gd_w1_end + 1;
         gd_w2_end   := gd_pd_end;
      end if;

      -- Insert into Control table a row for the new Period that will be
      -- preloaded
      insert into XXARG.XXARG_HR_OTL_CTRL_TBL
           values(ln_payroll_id
                 ,gd_pd_end
                 ,gd_w1_start
                 ,gd_w1_end
                 ,gd_w2_start
                 ,gd_w2_end
                 ,'N'      -- Payroll not run
                 ,sysdate
                 ,fnd_global.user_id
                 ,sysdate
                 ,fnd_global.user_id
                 );

      xxarg_hr_util_pkg.debug(gv_debug_mode,'Preloading Timecard for '
                                            || lv_payroll_name, 30);
      -- Populate Timecard for all eligible employees in the current payroll
      POP_EMPL_TIMECARD(ln_payroll_id
                       ,lv_payroll_name
                       ,ln_bus_grp_id);

   else
      -- Write into output file saying that Payroll has not yet been run
      -- for the old preloaded period
      g_retcode := 1;
      g_error_msg := 'Payroll needs to be run for previously loaded Timecard';
      fnd_file.put_line(fnd_file.output
                       ,'Payroll needs to be run for previously loaded Timecard');
   end if; -- if lv_flag = 'Y'

   xxarg_hr_util_pkg.debug(gv_debug_mode
                      ,'Leaving ' || gv_pkg_name || '.preload', 10);
    retcode := g_retcode;
    errbuf := g_error_msg;
EXCEPTION
   when others then
      retcode := 1;
      errbuf  := substr(SQLERRM,1,200);

END PRELOAD;

procedure upd_ctrl_tbl(errbuf        OUT VARCHAR2
                      ,retcode       OUT VARCHAR2
                      ,p_payroll     IN VARCHAR2
                      ,p_pd_end_date IN VARCHAR2
                      ,p_status      IN VARCHAR2) IS

   ld_pd_end_date date;
BEGIN

   fnd_file.put_line(FND_FILE.LOG, 'Payroll = ' || p_payroll);
   fnd_file.put_line(FND_FILE.LOG, 'Period End Date = ' || p_pd_end_date);
   fnd_file.put_line(FND_FILE.LOG, 'Status = ' || p_status);

   ld_pd_end_date := fnd_date.canonical_to_date(p_pd_end_date);

   update XXARG.XXARG_HR_OTL_CTRL_TBL
      set payroll_run = p_status
         ,last_update_date = sysdate
    where payroll_id = p_payroll
      and period_end_date = ld_pd_end_date;

END upd_ctrl_tbl;

procedure del_ctrl_tbl(errbuf        OUT VARCHAR2
                      ,retcode       OUT VARCHAR2
                      ,p_payroll     IN VARCHAR2
                      ,p_pd_end_date IN VARCHAR2) IS
   ld_pd_end_date date;
BEGIN

   fnd_file.put_line(FND_FILE.LOG, 'Payroll = ' || p_payroll);
   fnd_file.put_line(FND_FILE.LOG, 'Period End Date = ' || p_pd_end_date);

   ld_pd_end_date := fnd_date.canonical_to_date(p_pd_end_date);

   delete from XXARG.XXARG_HR_OTL_CTRL_TBL
    where payroll_id = p_payroll
      and period_end_date = ld_pd_end_date;

END del_ctrl_tbl;

procedure ins_ctrl_tbl(errbuf        OUT VARCHAR2
                      ,retcode       OUT VARCHAR2
                      ,p_payroll     IN  VARCHAR2
                      ,p_pd_end_date IN  VARCHAR2) IS

-- Cursor to get Next period end dates
cursor c_get_pd_dates(cp_payroll_id number
                     ,cp_date       date) is
select ptp.start_date
      ,ptp.end_date
      ,pap.period_type
  from per_time_periods ptp
      ,pay_all_payrolls_f pap
 where pap.payroll_id = cp_payroll_id
   and ptp.payroll_id = pap.payroll_id
   and cp_date between start_date
                   and end_date
   and cp_date between pap.effective_start_date
                   and pap.effective_end_date;

   ld_w1_start date;
   ld_w1_end   date;
   ld_w2_start date;
   ld_w2_end   date;
   ld_pd_start date;
   ld_pd_end   date;
   ld_end_date date;

   lv_period_type varchar2(30);
BEGIN
   ld_end_date := fnd_date.canonical_to_date(p_pd_end_date);
   -- Get the next period start date and end date based on the last
   -- processed payroll period end date
   open c_get_pd_dates(p_payroll
                      ,ld_end_date);
   fetch c_get_pd_dates into ld_pd_start
                            ,ld_pd_end
                            ,lv_period_type;
   close c_get_pd_dates;

      -- Calculate Week1 and Week2 dates
      -- Assumption :
      --    All payrolls in Wendys/Arbys group will be either Biweekly
      --    or Weekly
      if lv_period_type = 'Week' then
         ld_w1_start := ld_pd_start;
         ld_w1_end   := ld_pd_end;
      else
         ld_w1_start := ld_pd_start;
         ld_w1_end   := ld_pd_start + 6;
         ld_w2_start := ld_w1_end + 1;
         ld_w2_end   := ld_pd_end;
      end if;

      -- Insert into Control table a row for the new Period that will be
      -- preloaded
      insert into XXARG.XXARG_HR_OTL_CTRL_TBL
                 (payroll_id
                 ,period_end_date
                 ,week1_start_date
                 ,week1_end_date
                 ,week2_start_date
                 ,week2_end_date
                 ,payroll_run
                 ,last_update_date
                 ,last_updated_by
                 ,creation_date
                 ,created_by
                 )
           values(p_payroll
                 ,ld_pd_end
                 ,ld_w1_start
                 ,ld_w1_end
                 ,ld_w2_start
                 ,ld_w2_end
                 ,'N'      -- Payroll not run
                 ,sysdate
                 ,fnd_global.user_id
                 ,sysdate
                 ,fnd_global.user_id
                 );

    retcode := g_retcode;
    errbuf := g_error_msg;
END;

END xxarg_hr_otl_preload_pkg;
